import os
import numpy as np
import pandas as pd
import plotly.graph_objects as go
from src.model import solve_hjb_y, solve_hjb_y_jump
from src.utilities import find_nearest_value, solve_post_jump
from src.simulation import simulate_jump, no_jump_simulation
import pickle

# Preference
η = 0.032
δ = 0.01

# Climate sensitivity
θ_list = pd.read_csv('data/model144.csv', header=None).to_numpy()[:, 0] / 1000.
πc_o = np.ones_like(θ_list) / len(θ_list)

# Damage functions
σ_y = 1.2 * np.mean(θ_list)
y_underline = 1.5
y_bar = 2.
γ_1 = 1.7675 / 10000
γ_2 = 0.0022 * 2
γ_3 = np.linspace(0., 1. / 3, 20)
πd_o = np.ones_like(γ_3) / len(γ_3)

# capital evolution
α = 0.115
i_over_k = 0.09
K0 = 85 / α

# state variable
y_step = .01
y_grid_long = np.arange(0., 5., y_step)
y_grid_short = np.arange(0., 2.1 + y_step, y_step)
n_bar = find_nearest_value(y_grid_long, y_bar) 

# Prepare ϕ conditional on low, high, extreme damage
ξ_a = 0.01
ξ_r_list = [100_000, 5., 1., 0.3]
if not os.path.exists(f"data/v_list_{ξ_a}.pickle") and not os.path.exists(f"data/e_tilde_list_{ξ_a}.pickle"):
    v_list = {}
    e_tilde_list = {}
    for ξ_r, ξ_a in [(100_000, 100_000), (5., ξ_a), (1., ξ_a), (0.3, ξ_a)]:
        model_args_list = []
        for γ_3_m in γ_3:
            model_arg = (η, δ, σ_y, y_bar, γ_1, γ_2, γ_3_m, θ_list, πc_o, ξ_r, ξ_a)
            model_args_list.append((y_grid_long, model_arg, None, 1., 1e-8, 5_000, False))
        v_list[ξ_r], e_tilde_list[ξ_r] = solve_post_jump(y_grid_long, γ_3, solve_hjb_y, model_args_list)
    pickle.dump(v_list, open(f"data/v_list_{ξ_a}.pickle", "wb"))
    pickle.dump(e_tilde_list, open(f"data/e_tilde_list_{ξ_a}.pickle", "wb"))

v_list = pickle.load(open(f"data/v_list_{ξ_a}.pickle", "rb"))
e_tilde_list = pickle.load(open(f"data/e_tilde_list_{ξ_a}.pickle", "rb"))

if not os.path.exists(f"data/pre_jump_res_{ξ_a}.pickle"):
    pre_jump_res = {}
    ξ_r_list = [100_000, 5., 1., 0.3]
    for ξ_r_i in ξ_r_list:
        ϕ_list = v_list[ξ_r_i]
        certainty_equivalent = -ξ_r_i * np.log(
            np.average(
                np.exp(-1. / ξ_r_i * np.array(ϕ_list)), axis=0, weights=πd_o))
        # Change grid from 0-4 to 0-2
        ϕ_i = np.array(
            [temp[n_bar] * np.ones_like(y_grid_short) for temp in ϕ_list])

        # Compute ϕ with jump (impose boundary condition)
        if ξ_r_i == 100_000:
            ξ_a = 100_000
        else:
            ξ_a = 0.01
        model_args = (η, δ, σ_y, y_underline, y_bar, γ_1, γ_2, γ_3, θ_list, πc_o, ϕ_i, πd_o,
                      ξ_r_i, ξ_r_i, ξ_a)
        model_res = solve_hjb_y_jump(y_grid_short,
                                     model_args,
                                     v0=None,
                                     ϵ=1.,
                                     tol=1e-8,
                                     max_iter=5_000,
                                     print_iteration=False)
        simulation_res = no_jump_simulation(model_res, dt=1/4)
        pre_jump_res[ξ_r_i] = dict(model_res=model_res,
                               simulation_res=simulation_res,
                               certainty_equivalent=certainty_equivalent)
    pickle.dump(pre_jump_res, open(f"data/pre_jump_res_{ξ_a}.pickle", "wb"))

pre_jump_res = pickle.load(open(f"data/pre_jump_res_{ξ_a}.pickle", "rb"))

from src.plots import plot5
plot5(pre_jump_res)

from src.plots import plot6
plot6(pre_jump_res)

from src.plots import plot7
plot7(pre_jump_res)

# Repeat for 1.75 - 2.25
y_underline_higher = 1.75
y_bar_higher = 2.25
# state variable
y_step = .01
y_grid_short_2 = np.arange(0., 2.3 + y_step, y_step)
n_bar = find_nearest_value(y_grid_long, y_bar_higher)

# post jump value functions
if not os.path.exists(f"data/v175_list_{ξ_a}.pickle") and not os.path.exists(f"data/e175_tilde_list_{ξ_a}.pickle"):
    v175_list = {}
    e175_tilde_list = {}
    for ξ_r, ξ_a in [(100_000, 100_000), (5., 0.01), (1., 0.01), (0.3, 0.01)]:
        model_args_list = []
        for γ_3_m in γ_3:
            model_arg = (η, δ, σ_y, y_bar_higher, γ_1, γ_2, γ_3_m, θ_list, πc_o,
                         ξ_r, ξ_a)
            model_args_list.append(
                (y_grid_long, model_arg, None, 1., 1e-8, 5_000, False))
        v175_list[ξ_r], e175_tilde_list[ξ_r] = solve_post_jump(
            y_grid_long, γ_3, solve_hjb_y, model_args_list)
    pickle.dump(v_list, open(f"data/v175_list_{ξ_a}.pickle", "wb"))
    pickle.dump(e_tilde_list, open(f"data/e175_tilde_list_{ξ_a}.pickle", "wb"))
v175_list = pickle.load(open(f"data/v175_list_{ξ_a}.pickle", "rb"))
e175_tilde_list = pickle.load(open(f"data/e175_tilde_list_{ξ_a}.pickle", "rb"))

# pre jump value function
if not os.path.exists(f"data/pre_jump175_res_{ξ_a}.pickle"):
    pre_jump175_res = {}
    ξ_r_list = [100_000, 5., 1., 0.3]
    for ξ_r_i in ξ_r_list:
        ϕ_list = v175_list[ξ_r_i]
        certainty_equivalent = -ξ_r_i * np.log(
            np.average(
                np.exp(-1. / ξ_r_i * np.array(ϕ_list)), axis=0, weights=πd_o))
        # Change grid from 0-4 to 0-2
        ϕ_i = np.array(
            [temp[n_bar] * np.ones_like(y_grid_short_2) for temp in ϕ_list])

        # Compute ϕ with jump (impose boundary condition)
        if ξ_r_i == 100_000:
            ξ_a = 100_000
        else:
            ξ_a = 0.01
        model_args = (η, δ, σ_y, y_underline_higher, y_bar_higher, γ_1, γ_2, γ_3,
                      θ_list, πc_o, ϕ_i, πd_o, ξ_r_i, ξ_r_i, ξ_a)
        model_res = solve_hjb_y_jump(y_grid_short_2,
                                     model_args,
                                     v0=None,
                                     ϵ=1.,
                                     tol=1e-8,
                                     max_iter=5_000,
                                     print_iteration=False)
        simulation_res = no_jump_simulation(model_res, dt=1 / 4)
        pre_jump175_res[ξ_r_i] = dict(model_res=model_res,
                                      simulation_res=simulation_res,
                                      certainty_equivalent=certainty_equivalent)
    pickle.dump(pre_jump175_res, open(f"data/pre_jump175_res_{ξ_a}.pickle", "wb"))
pre_jump175_res = pickle.load(open(f"data/pre_jump175_res_{ξ_a}.pickle", "rb"))

from src.plots import plot_e_tilde
plot_e = go.Figure()
plot_e = plot_e_tilde(plot_e, pre_jump_res, y_grid_short_2, y_underline)
plot_e = plot_e_tilde(plot_e, pre_jump175_res, y_grid_short_2, y_underline_higher)
for i in range(len(ξ_r_list)):
    plot_e.data[i]["visible"] = True
    plot_e.data[i]["showlegend"] =True
buttons = []
# for 
plot_e.update_layout(
    title=
    r"""Figure 8 : Emissions as a function of the temperature anomaly.
   """
)
for i, (y_u, y_o) in enumerate([(y_underline, y_bar), (y_underline_higher, y_bar_higher)]):
    # Hide all traces
    button = dict(method='update',
                args=[
                    {
                        'visible': [False] * (len(ξ_r_list)*2),
                        'showlegend': [False] * (len(ξ_r_list)*2),
                    },
                ],
                label=r'\underline y = {} and \bar y = {}'.format(y_u, y_o))
    # Enable the two traces we want to see
    for j in range(len(ξ_r_list)):
        button['args'][0]["visible"][i*len(ξ_r_list) + j] = True
        button['args'][0]["showlegend"][i*len(ξ_r_list) + j] = True
    # Add step to step list
    buttons.append(button)

plot_e.update_layout(
    updatemenus=[
        dict(
            type="buttons",
            direction="right",
            active=0,
            x=0.95,
            y=1.15,
            buttons=buttons,
            pad={"r": 10, "t": 10, "b":10},
            showactive=True
        )
    ])

from src.plots import plot_logscc
args_scc = (α, η, i_over_k, K0, γ_1, γ_2)
fig_logscc = go.Figure()
fig_logscc = plot_logscc(fig_logscc, pre_jump_res, y_grid_short, 1.5, ξ_r_list, args_scc)
fig_logscc = plot_logscc(fig_logscc, pre_jump175_res, y_grid_short_2, 1.75, ξ_r_list, args_scc)
for i in range(len(ξ_r_list)):
    fig_logscc.data[i + len(ξ_r_list)]["visible"] = False
    fig_logscc.data[i + len(ξ_r_list)]["showlegend"] = False
buttons = []
# for 
fig_logscc.update_layout(title=r"$\text{Figure 9: }\log SCC \text{ as a function of the temperature anomaly.}$")
for i, (y_u, y_o) in enumerate([(y_underline, y_bar), (y_underline_higher, y_bar_higher)]):
    # Hide all traces
    button = dict(method='update',
                args=[
                    {
                        'visible': [False] * (len(ξ_r_list)*2),
                        'showlegend': [False] * (len(ξ_r_list)*2),
                    },
                ],
                label=r'\underline y = {} and \bar y = {}'.format(y_u, y_o))
    # Enable the two traces we want to see
    for j in range(len(ξ_r_list)):
        button['args'][0]["visible"][i*len(ξ_r_list) + j] = True
        button['args'][0]["showlegend"][i*len(ξ_r_list) + j] = True
    # Add step to step list
    buttons.append(button)
fig_logscc.update_layout(
    updatemenus=[
        dict(
            type="buttons",
            direction="right",
            active=0,
            x=0.95,
            y=1.15,
            buttons=buttons,
            pad={"r": 10, "t": 10, "b":10},
            showactive=True
        )
    ])
fig_logscc.update_yaxes(range=[4.4, 6])

from src.simulation import EvolutionState
from scipy import interpolate

e_grid_1 = pre_jump_res[1]["model_res"]["e_tilde"]
e_func_pre_damage = interpolate.interp1d(y_grid_short, e_grid_1)
e_grid_long_1 = e_tilde_list[1]
e_func_post_damage = [interpolate.interp1d(y_grid_long, e_grid_long_1[i]) for i in range(len(γ_3))]

# start simulation
e0 = 0
y0 = 1.1
temp_anol0 = 1.1
y_underline = 1.5
y_overline = 2.
initial_state = EvolutionState(t=0,
                               prob=1,
                               damage_jump_state='pre',
                               damage_jump_loc=None,
                               variables=[e0, y0, temp_anol0],
                               y_underline=y_underline,
                               y_overline=y_overline)

fun_args = (e_func_pre_damage, e_func_post_damage)

T = 410
sim_res = []
temp_anols = []
probs = []
damage_locs = []
sim_res.append([initial_state])
for i in range(T):
    if i == 0:
        states = initial_state.evolve(np.mean(θ_list), fun_args)
    else:
        temp = []
        for state in states:
            temp += state.evolve(np.mean(θ_list), fun_args)
        states = temp
    tempanol_t = []
    probs_t = []
    damage_loc_t = []
    for state in states:
        tempanol_t.append( state.variables[2] )
        probs_t.append( state.prob )
        damage_loc_t.append( state.damage_jump_loc )

    temp_anols.append(tempanol_t)
    probs.append(probs_t)
    damage_locs.append(damage_loc_t)
    sim_res.append(states)

import plotly.graph_objects as go
fig = go.Figure()
fig.add_trace(go.Scatter(x=γ_3, y=[state.variables[0] for state in sim_res[233][:20]]))
fig.update_xaxes(range=[-0.01, 1./3], showline=True, title=r"$\gamma_3$")
fig.update_yaxes(title="Emissions", range=[0, 10])

# Prepare ϕ conditional on low, high, extreme damage
ξ_r_dense = 1
ξ_a_dense = 0.01
γ_3_dense = np.linspace(0, 1/3, 100)
if not os.path.exists("data/ems_jump_date_dense.npy"):   
    model_args_list = []
    for γ_3_m in γ_3_dense:
        model_arg = (η, δ, σ_y, y_bar, γ_1, γ_2, γ_3_m, θ_list, πc_o, ξ_r_dense, ξ_a_dense)
        model_args_list.append((y_grid_long, model_arg, None, 1., 1e-8, 2_000, False))
    v_list_dense, e_tilde_dense = solve_post_jump(y_grid_long, γ_3_dense, solve_hjb_y, model_args_list)

    loc_2 = np.abs(y_grid_short - 2.).argmin()
    ems_jump_date_dense = np.zeros(len(γ_3_dense))
    for i in range(len(γ_3_dense)):
        ems_jump_date_dense[i] = e_tilde_dense[i][loc_2]
    np.save("data/ems_jump_date_dense", ems_jump_date_dense)
ems_jump_date_dense = np.load("data/ems_jump_date_dense.npy")

fig = go.Figure()
fig.add_trace(go.Scatter(x=γ_3_dense, y=ems_jump_date_dense))
fig.update_xaxes(range=[-0.01, 1./3], showline=True, title=r"$\gamma_3$")
fig.update_yaxes(title="Emissions", range=[0, 10])
fig.update_layout(title="Figure 10: Emissions choices, conditioned on a jump having occurred, for different γ3 upon realization of the jump.")

from src.plots import plot_ems_app
ξ_r_list = [100_000, 5, 1, 0.3]
emission_traj = plot_ems_app(pre_jump_res, y_grid_short, ξ_r_list, dt=1/4, model_res=False, truncate=True)
emission_traj.update_yaxes(range=[0,7])
emission_traj.update_xaxes(range=[0,70])

from src.plots import plot_ems_app
ξ_r_list = [100_000, 5, 1, 0.3]
emission_traj = plot_ems_app(pre_jump_res, y_grid_short, ξ_r_list, dt=1/4, model_res=False)
emission_traj.update_yaxes(range=[0,15])
