# packages
import pandas as pd
import numpy as np
from src.model import solve_hjb_y, solve_hjb_y_jump, solve_baseline, minimize_g, minimize_π
from src.utilities import find_nearest_value, solve_post_jump
from src.simulation import simulate_me
import plotly.io as pio
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.offline as pyo
import pickle
pyo.init_notebook_mode()

# preparation
ξ_w = 100_000
ξ_a = 0.01
ξ_r = 1.

ϵ = 5.
η = .032
δ = .01

θ_list = pd.read_csv('data/model144.csv', header=None).to_numpy()[:, 0]/1000.
πc_o = np.ones_like(θ_list)/len(θ_list)

σ_y = 1.2*np.mean(θ_list)
y_underline = 1.5
y_bar = 2.
γ_1 = 1.7675/10000
γ_2 = .0022*2
γ_3 = np.linspace(0., 1./3, 20)
πd_o = np.ones_like(γ_3)/len(γ_3)

y_step = .01
y_grid_long = np.arange(0., 5., y_step)
y_grid_short = np.arange(0., y_bar+y_step, y_step)
n_bar = find_nearest_value(y_grid_long, y_bar) 

# Uncertainty decomposition
n_temp = 16
n_carb = 9
θ_reshape = θ_list.reshape(n_temp, n_carb)
θ_temp = np.mean(θ_reshape, axis=1)
θ_carb = np.mean(θ_reshape, axis=0)
πc_o_temp = np.ones_like(θ_temp)/len(θ_temp)
πc_o_carb = np.ones_like(θ_carb)/len(θ_carb)

pre_jump_res = pickle.load(open("pre_jump_res", "rb"))
v_list = pickle.load(open("v_list", "rb"))
e_tilde_list = pickle.load(open("e_tilde_list", "rb"))

ems_star = pre_jump_res[1]["model_res"]['e_tilde']
ME_total = η / ems_star

ξ_a = 0.01
args = (δ, η, θ_list, γ_1, γ_2, γ_3, y_bar, πd_o, 100_000, 100_000, 100_000, σ_y, y_underline)
ME_base, ratio_base = solve_baseline(y_grid_long,
                                     n_bar,
                                     ems_star[:n_bar + 1],
                                     v_list[100_000], 
                                     args,
                                     ϵ=1.,
                                     tol=1e-8,
                                     max_iter=500)

# carbon
print("--------------Carbon-----------------")
args_list_carb = []
for γ_3_m in γ_3:
    args_func = (η, δ, σ_y, y_bar, γ_1, γ_2, γ_3_m, θ_carb, πc_o_carb, 100_000, ξ_a)
    args_iter = (y_grid_long, args_func, None, 1., 1e-8, 5_000, False)
    args_list_carb.append(args_iter)

ϕ_list_carb, ems_list_carb = solve_post_jump(y_grid_long, γ_3, solve_hjb_y, args_list_carb)
args = (δ, η, θ_carb, γ_1, γ_2, γ_3, y_bar, πd_o, 100_000, ξ_a, 100_000, σ_y, y_underline)
ME_carb, ratiocarb = minimize_π(y_grid_long, n_bar, ems_star[:n_bar + 1], ϕ_list_carb, args)

# temperature
print("-------------Temperature--------------")
args_list_temp = []
for γ_3_m in γ_3:
    args_func = (η, δ, σ_y, y_bar, γ_1, γ_2, γ_3_m, θ_temp, πc_o_temp, 100_000, ξ_a)
    args_iter = (y_grid_long, args_func, None, 1., 1e-8, 5_000, False)
    args_list_temp.append(args_iter)

ϕ_list_temp, ems_list_temp = solve_post_jump(y_grid_long, γ_3, solve_hjb_y, args_list_temp)
args = (δ, η, θ_temp, γ_1, γ_2, γ_3, y_bar, πd_o, 100_000, ξ_a, 100_000, σ_y, y_underline)
ME_temp, ratiotemp = minimize_π(y_grid_long, n_bar, ems_star[:n_bar + 1], ϕ_list_temp, args)

# damage
print("-------------------Damage-----------------")
args = (δ, η, θ_list, γ_1, γ_2, γ_3, y_bar, πd_o, 1, 100_000, 100_000, σ_y, y_underline)
ME_dmg, ratiotemp = minimize_g(y_grid_long, n_bar, ems_star[:n_bar + 1], v_list[100_000], args)

loc_11 = np.abs(y_grid_long - 1.1).argmin()
loc_15 = np.abs(y_grid_long - y_underline).argmin()
ratios = [
    np.log(ME_total[loc_11:loc_15 + 1] / ME_base[loc_11:loc_15 + 1]) * 100,
    np.log(ME_dmg[loc_11:loc_15 + 1] / ME_base[loc_11:loc_15 + 1]) * 100,
    np.log(ME_temp[loc_11:loc_15 + 1] / ME_base[loc_11:loc_15 + 1]) * 100,
    np.log(ME_carb[loc_11:loc_15 + 1] / ME_base[loc_11:loc_15 + 1]) * 100,
]

ξ_a = 0.005
pre_jump_res = pickle.load(open(f"pre_jump_res_{ξ_a}", "rb"))
v_list = pickle.load(open(f"v_list_{ξ_a}", "rb"))
e_tilde_list = pickle.load(open(f"e_tilde_list_{ξ_a}", "rb"))
ems_star = pre_jump_res[1]["model_res"]['e_tilde']
ME_total = η / ems_star
# perform uncertainty decomposition
args = (δ, η, θ_list, γ_1, γ_2, γ_3, y_bar, πd_o, 100_000, 100_000, 100_000, σ_y, y_underline)
ME_base, ratio_base = solve_baseline(y_grid_long,
                                     n_bar,
                                     ems_star[:n_bar + 1],
                                     v_list[100_000], 
                                     args,
                                     ϵ=1.,
                                     tol=1e-8,
                                     max_iter=1_000)

# carbon
print("--------------Carbon-----------------")
args_list_carb = []
for γ_3_m in γ_3:
    args_func = (η, δ, σ_y, y_bar, γ_1, γ_2, γ_3_m, θ_carb, πc_o_carb, 100_000, ξ_a)
    args_iter = (y_grid_long, args_func, None, 1., 1e-8, 5_000, False)
    args_list_carb.append(args_iter)

ϕ_list_carb, ems_list_carb = solve_post_jump(y_grid_long, γ_3, solve_hjb_y, args_list_carb)
args = (δ, η, θ_carb, γ_1, γ_2, γ_3, y_bar, πd_o, 100_000, ξ_a, 100_000, σ_y, y_underline)
ME_carb, ratiocarb = minimize_π(y_grid_long, n_bar, ems_star[:n_bar + 1], ϕ_list_carb, args)

# temperature
print("-------------Temperature--------------")
args_list_temp = []
for γ_3_m in γ_3:
    args_func = (η, δ, σ_y, y_bar, γ_1, γ_2, γ_3_m, θ_temp, πc_o_temp, 100_000, ξ_a)
    args_iter = (y_grid_long, args_func, None, 1., 1e-8, 5_000, False)
    args_list_temp.append(args_iter)

ϕ_list_temp, ems_list_temp = solve_post_jump(y_grid_long, γ_3, solve_hjb_y, args_list_temp)
args = (δ, η, θ_temp, γ_1, γ_2, γ_3, y_bar, πd_o, 100_000, ξ_a, 100_000, σ_y, y_underline)
ME_temp, ratiotemp = minimize_π(y_grid_long, n_bar, ems_star[:n_bar + 1], ϕ_list_temp, args)

# damage
print("-------------------Damage-----------------")
args = (δ, η, θ_list, γ_1, γ_2, γ_3, y_bar, πd_o, 1, 100_000, 100_000, σ_y, y_underline)
ME_dmg, ratiotemp = minimize_g(y_grid_long, n_bar, ems_star[:n_bar + 1], v_list[100_000], args, ϵ=0.5)

# list of ratios
ratios_0p005 = [
    np.log(ME_total[loc_11:loc_15 + 1] / ME_base[loc_11:loc_15 + 1]) * 100,
    np.log(ME_dmg[loc_11:loc_15 + 1] / ME_base[loc_11:loc_15 + 1]) * 100,
    np.log(ME_temp[loc_11:loc_15 + 1] / ME_base[loc_11:loc_15 + 1]) * 100,
    np.log(ME_carb[loc_11:loc_15 + 1] / ME_base[loc_11:loc_15 + 1]) * 100,
]

from src.plots import plot13
fig = go.Figure(layout=dict(width=800, height=500, plot_bgcolor="white"))
fig = plot13(fig, ratios, y_grid_long, y_underline)
fig = plot13(fig, ratios_0p005, y_grid_long, y_underline)
for i in range(int(len(fig.data)/2)):
    fig.data[int(len(fig.data)/2) + i]["visible"] = False
buttons = []
ξ_a_s = [0.01, 0.005]
for i in range(len(ξ_a_s)):
    # Hide all traces
    button = dict(method='update',
                args=[
                    {
                        'visible': [False] * len(fig.data),
                        'showlegend': [False] *len(fig.data),
                    },
                ],
                label="ξa = {}".format(ξ_a_s[i]))
    # Enable the two traces we want to see
    for j in range(int(len(fig.data)/2)):
        button['args'][0]["visible"][int(len(fig.data)/2)*i + j] = True
        button['args'][0]["showlegend"][int(len(fig.data)/2)*i + j] = True
    # Add step to step list
    buttons.append(button)

fig.update_layout(
    updatemenus=[
        dict(
            type="buttons",
            active=0,
            x=1.23,
            y=0.75,
            buttons=buttons,
            pad={"r": 10, "t": 10, "b":10},
            showactive=True
        )
    ])
fig.update_yaxes(range=[0, 50])
fig
